# 2.6: Synchronizing app in the background

![Placeholder Banner Only. Replace when final assets ready.](_media/day-01.png)

Welcome to day 14 of the [30 Days of PWA](https://aka.ms/learn-pwa/30Days-blog) series! Today's blog post will introduce Background Services of modern browsers and how to use them for different kinds of synchronizations.

Author: Maxim Salnikov [@webmaxru](https://twitter.com/webmaxru)

## Background services

Modern browsers and Service Worker APIs bring exciting new features to the web. Now, you can run some pieces of your frontend code completely independently from the main application lifecycle. That means you are no longer limited to architecting and building your application as something that only starts when the user opens the corresponding URL and immediately ends right after they close the tab. Now, parts of your code can be executed even when there is no browser window with your application open in it, i.e. in the background. And this can happen with or without notifying the user. It's you, as a developer, who decide.

There is a bunch of APIs forming the **Background Services** feature in Chromium-based browsers which allow you to run code in the background. Today, we'll have a closer look at two of them that make it possible to synchronize data between your application and the browser: **Background Sync API** and **Periodic Background Sync API**.

## One-off synchronization on restoring the connection

The web is historically too dependent on internet connectivity. It doesn't work well for it as for an application platform where you expect that once you downloaded and installed the application it should just work, online or offline (if we talk about features that do not fully rely on the communication with remote servers). The offline-readiness of the application itself was "fixed" by using a combination of the core Service Worker API events `install`, `activate`, `fetch` and Cache Storage. But what's about the requests that the app does during runtime? How to provide a smooth user experience when there is no internet connection?

Background Sync API is here to help. It allows developers to think about frontend app <-> server communication as about a set of _syncs_. These syncs will happen immediately after they were created ("registered" in terms of Background Sync API) if the connection is available or, if there is no connection, later when the user goes back online. What differs this way from all other pre-PWA approaches is: this "later" will also work even _after_ the user closed the application tab and/or the visible part of the browser - thanks to the service worker that is always "on duty" in the background.

Please note, this API only provides a `sync` event to the service worker. You have to implement preserving the data you want to send (in case of delayed sending because of offline) and sending the data itself. You might need to think about where to store the data (IndexedDB is a good option) and about organizing queuing if you want to support multiple sends within one sync.

There are lots of scenarios for background sync but the most straightforward and widespread one is the following: repeating requests to the server done offline (i.e. failed ones) after the connection is restored. Let's see how it works in practice for a web-based social media client.

### How to start

In your main application code, after the user created a new post and clicked "Publish" you check if the request to the server failed. If it did, you create a _sync_ for this attempt. You need an active service worker registration to do that.

```javascript
async function publishPostOnConnected(post) {
  const registration = await navigator.serviceWorker.ready;
  try {
    // First, you should write a code to save the data you want to send later. It's a good idea to have this function ready for multiple posts published while offline. Using IndexedDB is the best option for storing this kind of data.
    await savePost(post);

    // Then, the sync registration itself. We give it a name because we can have multiple syncs for various parts of the app functionality:
    await registration.sync.register('sync-post');

    // Finally, you can inform the user about it:
    showNotification('Your post will be published automatically right after connection is restored. It is safe to close the app.');
  } catch {
    console.error('Background Sync registration failed');
  }
}
```

It's a really good idea to wrap this code by a feature detection:

```javascript
if ('serviceWorker' in navigator && 'SyncManager' in window) {
   publishPostOnConnected(post)
} else {
  console.log('Background Sync is not supported');
}
```

In the service worker, you listen and react to the `sync` event named `sync-post`:

```javascript
self.addEventListener('sync', event => {
    if (event.tag === 'sync-post') {
      event.waitUntil(

        // You have to implement the function that iterates over the preserved posts and sends them:
        publishSavedPosts()
      );
    }
});
```

Here, `publishSavedPosts` function should return a promise indicating the success/failure of sending data. If it's rejected, the next sync will be scheduled to retry.

Retrying failed requests can be automated and implemented in a declarative way by using the [Workbox Background Sync](https://developers.google.com/web/tools/workbox/modules/workbox-background-sync) module.

## Periodic synchronization

THe majority of the platforms have APIs that allow native applications to periodically run some tasks in the background without the user's interaction. For example, a social media app can fetch and store new posts from the server from time to time - to display a fresher feed when the user starts the app. Talking about the freshness of the application itself - mobile platforms have built-in mechanisms for that, desktop platforms allow developers to build corresponding services.

What's about the web? Can we keep installed web frontend application and data it uses up to date on our users' devices? Yes! With the API called Periodic Background Sync API, we can ask the background service of the browser to run parts of our code with some periodicity regardless of the main application status (whether it's running or not). Like Background Sync, this API only provides an event to the service worker - you have to implement the actual "payload" yourself. For example, it could be a fetch to check for the updated app version and/or its content followed by corresponding resources update in the browser cache.

Let's see how it works for a web-based social media client that can periodically update its main feed content in the background.

### How to start

It's a really good idea to let the user decide if they want to use this feature or not. Using `PeriodicSyncManager` interface of the registered service worker you can list existing "periodic syncs" to set the value (on/off) of UI controls (switches, checkboxes, etc) labeled like "Update feed in the background". When the user turns on this feature, you should register a new periodic sync:

```javascript
async function registerPeriodicFeedUpdate() {
  const registration = await navigator.serviceWorker.ready;

  // Query and check permission. See "Privacy and resource utilization considerations" section below.
  const status = await navigator.permissions.query({
    name: 'periodic-background-sync',
  });
  if (status.state !== 'granted') {
  {
    console.log('Periodic Background Sync is not granted.');
    return;
  }

  try {
    await registration.periodicSync.register('update-feed-content', {
      minInterval: 24 * 60 * 60 * 1000, // We ask browser to run the sync no more than once a day
    });
    showNotification('Success! Feed will be updated in the background.');

  } catch() {
    console.error('Periodic Background Sync registration failed');
  }
}
```

Like always in PWA, feature detection is a best practice:

```javascript
if ('serviceWorker' in navigator && 'PeriodicSyncManager' in window) {
   registerPeriodicFeedUpdate(post)
} else {
  console.log('Periodic Background Sync is not supported');
}
```

In the service worker, you should listen and react to the `periodicsync` event named `update-feed-content`:

```javascript
self.addEventListener('periodicsync', event => {
  if (event.tag === 'update-feed-content') {
      event.waitUntil(

        // You have to implement the function that fetches the latest posts and updates the storage:
        updateFeedContent()
      );
  }
});
```

Please note, that it's not an obligation but a possibility for you to fetch new data in `updateFeedContent` function. Before sending a server request, you might want to check if the user is on a non-metered connection and if there is enough space in the browser storage using Network Information and StorageManager APIs respectively.

## Privacy and resource utilization considerations

Both Background Sync and Periodic Background Sync APIs are designed to run some custom code (that might send network requests) in the background, at any time, and without notifying a user. It raises at least two concerns: privacy and resource utilization. Any network request is potentially a history leaking and location tracking reason. And any code consumes CPU, memory, battery, and, if needed, network resources. To avoid these problems, both specifications have requirements and recommendations that browser vendors must follow while implementing these APIs. They include:

- Having Background Sync permission granted for the origin. It has `allow` state by default but users can deny it.

![Background Sync permission](_media/background-sync-permission.png)

- Capping the number of background sync retries and duration of periodic syncs. It's not defined in API specification, but for the periodic sync intervals, browsers use the _Site Engagement_ index (number and duration of user interactions) for the particular origin on a particular device to calculate the exact intervals. At best it is a few hours. Hint: you can check the Site Engagement index for yourself on your current Chromium-based browser by visiting [about://site-engagement/](about://site-engagement/) url.
- Code execution time is limited by the service worker's lifetime which is a few seconds. So abusing device hardware by heavy computation or overusing network resources is rather difficult. For downloading the large files and having their content available for your frontend app, you can use [Background Fetch API](https://docs.microsoft.com/en-us/microsoft-edge/progressive-web-apps-chromium/how-to/background-syncs#use-the-background-fetch-api-to-fetch-large-files-when-the-app-or-service-worker-isnt-running) from the same background services family. This API is designed to keep the user in full control of the long network operation by displaying a browser native UI component with the download progress and Pause/Cancel/Resume buttons.
- Both `sync` and `periodicsync` events are only fired online. For Background Sync detecting online is a main and only purpose. While for Periodic Background Sync this limitation emphasizes the intended use case: keeping the application itself and/or its data up-to-date by periodically syncing with the server.

Periodic Background Sync API has a few additional requirements:

- The `periodicsync` will happen only on a known network (the one user was connected to before).
- It only works for _installed_ web applications.

Please note, that the limitations listed above are a current "snapshot" which is a mix of MAY, SHOULD, MUST statements of the respective specifications and some additional voluntary steps from the browser vendors.

## Testing and debugging

Checking how the background services you implemented work might be not an easy task: you as a developer do not have full control over the exact times when sync events come to a service worker. Fortunately, we have a set of helpers in the Chromium-based browser DevTools.

Go to Application -> Service Workers pane to send `sync` and `periodicsync` events to the service worker manually:

![Sending events manually](_media/background-sync-devtools-send.png)

In the Background Services section of the Application tab, you can click on the API you want to debug to see the events (both "real" and "manual") that were sent to the service worker. To "catch" and debug the real ones (distributed over hours and days if we talk about periodic syncs), you can use the "Record" icon to log the events for up to three days.

![Logging background service events](_media/background-sync-devtools-record.png)

## Learn more about background synchronization

- [Synchronize and update a PWA in the background](https://docs.microsoft.com/en-us/microsoft-edge/progressive-web-apps-chromium/how-to/background-syncs) article on Microsoft Docs
- Specifications for [Background Sync API](https://wicg.github.io/background-sync/spec/) and [Periodic Background Sync API](https://wicg.github.io/periodic-background-sync/)
- API documentation for [Background Sync API](https://developer.mozilla.org/en-US/docs/Web/API/Background_Synchronization_API) and [Periodic Background Sync API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Periodic_Background_Synchronization_API) on Mozilla Developer Network.